<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number of Articles Mentioning Selected Keywords Over Time</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        .chart-container {
            position: relative;
            width: 100%;
            padding-bottom: 50%;
        }
        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .line {
            fill: none;
            stroke-width: 2px;
            opacity: 1;
            transition: opacity 0.2s ease;
        }
        .line.dimmed {
            opacity: 0.2;
        }
        .axis-label {
            font-size: 12px;
            font-weight: 500;
        }
        .tooltip {
            position: absolute;
            padding: 12px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            pointer-events: none;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 200px;
        }
        .tooltip strong {
            font-weight: 600;
        }
        text {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        .legend-item {
            cursor: pointer;
        }
        .legend-item.inactive text {
            opacity: 0.5;
        }
        .legend-item.inactive rect {
            opacity: 0.5;
        }
        .hidden {
            opacity: 0;
        }
        .title {
            font-size: 16px;
            font-weight: 600;
            text-anchor: middle;
        }
        @media (max-width: 768px) {
            .chart-container {
                padding-bottom: 75%;
            }
            .title {
                font-size: 14px;
            }
            .axis-label {
                font-size: 10px;
            }
            .tooltip {
                font-size: 10px;
                padding: 8px;
            }
        }
        .slider-container {
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            background: #f5f5f7;
            border-radius: 12px;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }

        .year-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 0 10px;
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }

        .year-labels span {
            background: #fff;
            padding: 4px 12px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .range-slider {
            position: relative;
            width: calc(100% - 20px);
            height: 30px;
            margin: 20px auto;
            margin-bottom: 0;
        }

        .range-slider::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .range {
            position: absolute;
            width: 100%;
            height: 4px;
            background: none;
            pointer-events: none;
            -webkit-appearance: none;
            appearance: none;
            margin: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .range:focus {
            outline: none;
        }

        .range::-webkit-slider-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            pointer-events: auto;
            -webkit-appearance: none;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        .range::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #357abd;
        }

        .range::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            pointer-events: auto;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        .range::-moz-range-thumb:hover {
            transform: scale(1.1);
            background: #357abd;
        }

        .range::-webkit-slider-runnable-track,
        .range::-moz-range-track {
            background: transparent;
            border: none;
        }

        #year-start {
            z-index: 2;
        }

        @media (max-width: 768px) {
            .slider-container {
                padding: 15px;
                margin: 15px auto;
            }

            .year-labels {
                font-size: 12px;
            }

            .year-labels span {
                padding: 3px 8px;
            }
        }
        .legend-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }
        .dot {
            transition: opacity 0.2s ease;
        }
        .dot.dimmed {
            opacity: 0.2;
        }
        .save-button {
            padding: 8px 16px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: block;
            margin: 20px auto;
        }

        @media (max-width: 768px) {
            .save-button {
                padding: 6px 12px;
                font-size: 12px;
            }
        }
        .annotation-line {
            stroke: #666;
            stroke-width: 1.5;
            stroke-dasharray: 2,2;
        }

        .annotation-text {
            font-size: 11px;
            fill: #333;
            font-weight: 500;
        }

        .annotation-bg {
            fill: rgba(255, 255, 255, 0.9);
            stroke: #ddd;
            stroke-width: 1;
        }

        @media (max-width: 768px) {
            .annotation-text {
                font-size: 9px;
            }
        }
        .annotation-group {
            cursor: pointer;
        }

        .annotation-group:hover .annotation-bg {
            fill: rgba(255, 255, 255, 1);
            stroke: #666;
            stroke-width: 1.5;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .annotation-group:hover .annotation-text {
            font-weight: 600;
        }

        .annotation-group:hover .annotation-line {
            stroke: #666;
            stroke-width: 2;
            stroke-dasharray: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="chart-container">
            <svg></svg>
        </div>
        <div class="slider-container">
            <div class="year-labels">
                <span id="start-year"></span>
                <span id="end-year"></span>
            </div>
            <div class="range-slider">
                <input type="range" id="year-start" class="range">
                <input type="range" id="year-end" class="range">
            </div>
        </div>
        <button class="save-button">Save as SVG</button>
    </div>
    <script>
        function createChart() {
            // Clear previous chart if any
            d3.select("svg").selectAll("*").remove();

            const container = document.querySelector('.chart-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const margin = {
                top: height * 0.08,
                right: width * 0.15,
                bottom: height * 0.15,
                left: width * 0.1
            };

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const svg = d3.select("svg")
                .attr("width", width)
                .attr("height", height);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add title
            svg.append("text")
                .attr("class", "title")
                .attr("x", width / 2)
                .attr("y", margin.top / 2)
                .text("Number of Articles Mentioning Selected Keywords Over Time");

            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            const parseYear = d3.timeParse("%Y");
            const x = d3.scaleTime().range([0, chartWidth]);
            const y = d3.scaleLinear().range([chartHeight, 0]);
            const z = d3.scaleOrdinal(d3.schemeCategory10);

            const line = d3.line()
                .x(d => x(d.year))
                .y(d => y(d.total_count));

            // Load and process data
            d3.json("yearly_counts.json").then(data => {
                // Transform data (same as before)
                const transformedData = [];
                data.forEach(yearData => {
                    yearData.keywords.forEach(keywordData => {
                        transformedData.push({
                            year: parseYear(yearData.year),
                            keyword: keywordData.keyword,
                            total_count: keywordData.total_count,
                            countries: keywordData.countries
                        });
                    });
                });

                const keywords = Array.from(new Set(transformedData.map(d => d.keyword)));
                const dataNest = d3.groups(transformedData, d => d.keyword);

                x.domain(d3.extent(transformedData, d => d.year));
                y.domain([0, d3.max(transformedData, d => d.total_count)]);

                const years = Array.from(new Set(transformedData.map(d => d.year.getFullYear())));
                const minYear = Math.min(...years);
                const maxYear = Math.max(...years);

                // Initialize slider values
                const yearStartSlider = document.getElementById('year-start');
                const yearEndSlider = document.getElementById('year-end');
                const startYearLabel = document.getElementById('start-year');
                const endYearLabel = document.getElementById('end-year');

                yearStartSlider.min = minYear;
                yearStartSlider.max = maxYear;
                yearStartSlider.value = minYear;

                yearEndSlider.min = minYear;
                yearEndSlider.max = maxYear;
                yearEndSlider.value = maxYear;

                startYearLabel.textContent = minYear;
                endYearLabel.textContent = maxYear;

                // Define historical events
                const historicalEvents = [
                    {
                        year: "1991",
                        event: "Start of Algerian Civil War",
                        description: "FIS banned, beginning of armed conflict"
                    },
                    {
                        year: "1995",
                        event: "Peak of Violence",
                        description: "GIA campaigns intensify"
                    },
                    {
                        year: "2002",
                        event: "End of Civil War",
                        description: "Major conflict ends"
                    }
                ];

                // Add annotations
                const annotations = g.append("g")
                    .attr("class", "annotations");

                // Create annotation groups for each event
                const annotationGroups = annotations.selectAll(".annotation-group")
                    .data(historicalEvents)
                    .enter()
                    .append("g")
                    .attr("class", "annotation-group")
                    .attr("data-year", d => d.year)
                    .on("mouseover", function(event, d) {
                        // Bring this annotation group to front
                        this.parentNode.appendChild(this);
                        
                        // Dim all lines and dots
                        d3.selectAll(".line").style("opacity", 0.2);
                        d3.selectAll(".dot").style("opacity", 0.2);
                        
                        // Show tooltip with additional information
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        
                        tooltip.html(`<strong>${d.event}</strong><br/>${d.description}`)
                            .style("left", `${event.pageX + 10}px`)
                            .style("top", `${event.pageY - 28}px`);
                    })
                    .on("mouseout", function() {
                        // Restore lines and dots
                        d3.selectAll(".line").style("opacity", 1);
                        d3.selectAll(".dot").style("opacity", 1);
                        
                        // Hide tooltip
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // Add lines
                annotationGroups.append("line")
                    .attr("class", "annotation-line")
                    .attr("x1", d => x(parseYear(d.year)))
                    .attr("x2", d => x(parseYear(d.year)))
                    .attr("y1", d => y(0))
                    .attr("y2", d => {
                        const yearData = transformedData.filter(td => td.year.getFullYear() === parseInt(d.year));
                        const maxY = d3.max(yearData, yd => yd.total_count) || 0;
                        return y(maxY) - 100;
                    });

                // Add text
                annotationGroups.append("text")
                    .attr("class", "annotation-text")
                    .attr("x", d => x(parseYear(d.year)))
                    .attr("y", d => {
                        const yearData = transformedData.filter(td => td.year.getFullYear() === parseInt(d.year));
                        const maxY = d3.max(yearData, yd => yd.total_count) || 0;
                        return y(maxY) - 105;
                    })
                    .attr("text-anchor", "middle")
                    .text(d => d.event);

                // Add background rectangles (inserted before text)
                annotationGroups.insert("rect", "text")
                    .attr("class", "annotation-bg")
                    .each(function(d) {
                        const text = d3.select(this.parentNode).select("text");
                        const bbox = text.node().getBBox();
                        const padding = 4;
                        d3.select(this)
                            .attr("x", bbox.x - padding)
                            .attr("y", bbox.y - padding)
                            .attr("width", bbox.width + (padding * 2))
                            .attr("height", bbox.height + (padding * 2))
                            .attr("rx", 3);
                    });

                // Update function
                function updateChart(activeKeywords) {
                    const startYear = parseInt(yearStartSlider.value);
                    const endYear = parseInt(yearEndSlider.value);
                    
                    const activeData = transformedData.filter(d => 
                        activeKeywords.includes(d.keyword) &&
                        d.year.getFullYear() >= startYear &&
                        d.year.getFullYear() <= endYear
                    );
                    
                    // Update x and y domains based on filtered data
                    x.domain([new Date(startYear, 0, 1), new Date(endYear, 11, 31)]);
                    const maxY = d3.max(activeData, d => d.total_count) || 0;
                    y.domain([0, maxY * 1.4]); // Increased padding for higher annotations

                    // Update axes
                    g.select(".axis--x")
                        .transition()
                        .duration(750)
                        .call(d3.axisBottom(x)
                            .ticks(width < 600 ? d3.timeYear.every(5) : d3.timeYear.every(2)))
                        .selectAll("text")
                        .attr("transform", "rotate(-45)")
                        .style("text-anchor", "end");

                    g.select(".axis--y")
                        .transition()
                        .duration(750)
                        .call(d3.axisLeft(y));

                    // Update lines
                    dataNest.forEach(([keyword, values]) => {
                        const isActive = activeKeywords.includes(keyword);
                        const filteredValues = values.filter(d => 
                            d.year.getFullYear() >= startYear && 
                            d.year.getFullYear() <= endYear
                        );
                        
                        const lineId = `line-${keyword.replace(/\s+/g, '-')}`;
                        const dotsClass = `dots-${keyword.replace(/\s+/g, '-')}`;

                        // Update line
                        d3.select(`#${lineId}`)
                            .classed("hidden", !isActive)
                            .transition()
                            .duration(750)
                            .attr("d", line(filteredValues));

                        // Remove existing dots
                        g.selectAll(`.${dotsClass}`).remove();

                        // Add new dots if keyword is active
                        if (isActive) {
                            g.selectAll(`.${dotsClass}`)
                                .data(filteredValues.filter(d => d.total_count > 0))
                                .enter().append("circle")
                                .attr("class", `dot ${dotsClass}`)
                                .attr("r", width < 600 ? 3 : 4)
                                .attr("cx", d => x(d.year))
                                .attr("cy", d => y(d.total_count))
                                .style("fill", z(keyword))
                                .on("mouseover", function(event, d) {
                                    // Dim all lines and dots
                                    d3.selectAll(".line").classed("dimmed", true);
                                    d3.selectAll(".dot").classed("dimmed", true);
                                    
                                    // Highlight the corresponding line and dots
                                    const lineId = `line-${keyword.replace(/\s+/g, '-')}`;
                                    d3.select(`#${lineId}`).classed("dimmed", false);
                                    d3.selectAll(`.${dotsClass}`).classed("dimmed", false);
                                    
                                    // Show tooltip
                                    tooltip.transition()
                                        .duration(200)
                                        .style("opacity", .9);
                                    
                                    let tooltipContent = `<strong>${keyword}</strong><br/>`;
                                    tooltipContent += `Year: ${d.year.getFullYear()}<br/>`;
                                    tooltipContent += `Total: ${d.total_count}<br/><br/>`;
                                    
                                    if (d.countries && d.countries.length > 0) {
                                        tooltipContent += "<strong>By Country:</strong><br/>";
                                        d.countries.forEach(country => {
                                            tooltipContent += `${country.name}: ${country.count}<br/>`;
                                        });
                                    }
                                    
                                    tooltip.html(tooltipContent)
                                        .style("left", `${event.pageX + 10}px`)
                                        .style("top", `${event.pageY - 28}px`);
                                })
                                .on("mouseout", function() {
                                    // Restore all lines and dots to full opacity
                                    d3.selectAll(".line").classed("dimmed", false);
                                    d3.selectAll(".dot").classed("dimmed", false);
                                    
                                    // Hide tooltip
                                    tooltip.transition()
                                        .duration(500)
                                        .style("opacity", 0);
                                });
                        }
                    });

                    // Update annotations
                    annotationGroups.each(function(d) {
                        const group = d3.select(this);
                        const eventYear = parseInt(d.year);
                        const isInRange = eventYear >= startYear && eventYear <= endYear;
                        const xPos = x(parseYear(d.year));
                        
                        // Find the maximum y-value for this year
                        const yearData = activeData.filter(td => td.year.getFullYear() === eventYear);
                        const maxY = d3.max(yearData, yd => yd.total_count) || 0;
                        const adjustedYPos = y(maxY) - 100;

                        if (isInRange) {
                            // Update line
                            group.select(".annotation-line")
                                .transition()
                                .duration(750)
                                .style("opacity", 1)
                                .attr("x1", xPos)
                                .attr("x2", xPos)
                                .attr("y1", y(0))
                                .attr("y2", adjustedYPos);

                            // Update text first (without transition)
                            const textElement = group.select(".annotation-text")
                                .attr("x", xPos)
                                .attr("y", adjustedYPos - 5);
                            
                            // Get the new text bounding box
                            const bbox = textElement.node().getBBox();
                            const padding = 4;

                            // Update background rectangle position
                            group.select(".annotation-bg")
                                .attr("x", bbox.x - padding)
                                .attr("y", bbox.y - padding)
                                .attr("width", bbox.width + (padding * 2))
                                .attr("height", bbox.height + (padding * 2));

                            // Now add the transitions for opacity
                            textElement.transition()
                                .duration(750)
                                .style("opacity", 1);

                            group.select(".annotation-bg")
                                .transition()
                                .duration(750)
                                .style("opacity", 1);
                        } else {
                            // Hide all elements if out of range
                            group.selectAll("line, text, rect")
                                .transition()
                                .duration(750)
                                .style("opacity", 0);
                        }
                    });
                }

                // Add axes
                g.append("g")
                    .attr("class", "axis axis--x")
                    .attr("transform", `translate(0,${chartHeight})`)
                    .call(d3.axisBottom(x)
                        .ticks(width < 600 ? d3.timeYear.every(5) : d3.timeYear.every(2)))
                    .selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");

                g.append("text")
                    .attr("class", "axis-label")
                    .attr("text-anchor", "middle")
                    .attr("x", chartWidth/2)
                    .attr("y", chartHeight + margin.bottom * 0.8)
                    .text("Year");

                g.append("g")
                    .attr("class", "axis axis--y")
                    .call(d3.axisLeft(y))
                    .append("text")
                    .attr("class", "axis-label")
                    .attr("fill", "#000")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -margin.left * 0.7)
                    .attr("x", -chartHeight/2)
                    .attr("text-anchor", "middle")
                    .text("Number of Articles");

                // Add lines and dots (similar to before)
                const keyword = g.selectAll(".keyword")
                    .data(dataNest)
                    .enter().append("g")
                    .attr("class", "keyword");

                keyword.append("path")
                    .attr("class", "line")
                    .attr("id", d => `line-${d[0].replace(/\s+/g, '-')}`)
                    .attr("d", d => line(d[1]))
                    .style("stroke", d => z(d[0]))
                    .on("mouseover", function(event, d) {
                        // Dim all lines
                        d3.selectAll(".line").classed("dimmed", true);
                        d3.selectAll(".dot").classed("dimmed", true);
                        
                        // Highlight this line
                        d3.select(this).classed("dimmed", false);
                        
                        // Highlight corresponding dots
                        d3.selectAll(`.dots-${d[0].replace(/\s+/g, '-')}`).classed("dimmed", false);
                        
                        // Show tooltip for the nearest point
                        const mouseX = d3.pointer(event)[0];
                        const hoveredYear = x.invert(mouseX);
                        const bisect = d3.bisector(d => d.year).left;
                        const index = bisect(d[1], hoveredYear);
                        const point = d[1][index];
                        
                        if (point) {
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            
                            let tooltipContent = `<strong>${point.keyword}</strong><br/>`;
                            tooltipContent += `Year: ${point.year.getFullYear()}<br/>`;
                            tooltipContent += `Total: ${point.total_count}<br/><br/>`;
                            
                            if (point.countries.length > 0) {
                                tooltipContent += "<strong>By Country:</strong><br/>";
                                point.countries.forEach(country => {
                                    tooltipContent += `${country.name}: ${country.count}<br/>`;
                                });
                            }
                            
                            tooltip.html(tooltipContent)
                                .style("left", `${event.pageX + 10}px`)
                                .style("top", `${event.pageY - 28}px`);
                        }
                    })
                    .on("mouseout", function() {
                        // Restore all lines and dots to full opacity
                        d3.selectAll(".line").classed("dimmed", false);
                        d3.selectAll(".dot").classed("dimmed", false);
                        
                        // Hide tooltip
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // Add dots with tooltips
                dataNest.forEach(keywordGroup => {
                    const keyword = keywordGroup[0];
                    const values = keywordGroup[1];
                    const keywordClass = `dots-${keyword.replace(/\s+/g, '-')}`;
                    
                    g.selectAll(`.${keywordClass}`)
                        .data(values.filter(d => d.total_count > 0))
                        .enter().append("circle")
                        .attr("class", `dot ${keywordClass}`)
                        .attr("r", width < 600 ? 3 : 4)
                        .attr("cx", d => x(d.year))
                        .attr("cy", d => y(d.total_count))
                        .style("fill", z(keyword))
                        .on("mouseover", function(event, d) {
                            // Dim all lines and dots
                            d3.selectAll(".line").classed("dimmed", true);
                            d3.selectAll(".dot").classed("dimmed", true);
                            
                            // Highlight the corresponding line and dots
                            const lineId = `line-${keyword.replace(/\s+/g, '-')}`;
                            const dotsClass = `dots-${keyword.replace(/\s+/g, '-')}`;
                            
                            d3.select(`#${lineId}`).classed("dimmed", false);
                            d3.selectAll(`.${dotsClass}`).classed("dimmed", false);
                            
                            // Show tooltip
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            
                            let tooltipContent = `<strong>${keyword}</strong><br/>`;
                            tooltipContent += `Year: ${d.year.getFullYear()}<br/>`;
                            tooltipContent += `Total: ${d.total_count}<br/><br/>`;
                            
                            if (d.countries && d.countries.length > 0) {
                                tooltipContent += "<strong>By Country:</strong><br/>";
                                d.countries.forEach(country => {
                                    tooltipContent += `${country.name}: ${country.count}<br/>`;
                                });
                            }
                            
                            tooltip.html(tooltipContent)
                                .style("left", `${event.pageX + 10}px`)
                                .style("top", `${event.pageY - 28}px`);
                        })
                        .on("mouseout", function() {
                            // Restore all lines and dots to full opacity
                            d3.selectAll(".line").classed("dimmed", false);
                            d3.selectAll(".dot").classed("dimmed", false);
                            
                            // Hide tooltip
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });
                });

                // Add legend with improved positioning
                const isDesktop = width >= 768;
                
                // Desktop: right side, vertically aligned
                // Mobile: below the graph, in rows
                const legendConfig = isDesktop ? {
                    x: chartWidth + margin.left,
                    y: margin.top,
                    layout: 'vertical',
                    itemsPerRow: 1,
                    spacing: 20,
                    textOffset: 15
                } : {
                    x: margin.left,  // Start from left margin
                    y: height + 20,  // Position below graph
                    layout: 'horizontal',
                    itemsPerRow: width < 500 ? 2 : 3,  // 2 items per row for very small screens
                    spacing: width < 500 ? width / 2.5 : width / 3.5,
                    textOffset: 15
                };

                // Adjust container height for mobile to accommodate legend
                if (!isDesktop) {
                    const legendRows = Math.ceil(keywords.length / legendConfig.itemsPerRow);
                    const totalLegendHeight = legendRows * 25; // Height per row
                    const extraPadding = 40; // Additional padding
                    container.style.paddingBottom = `calc(75% + ${totalLegendHeight + extraPadding}px)`;
                }

                const legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${legendConfig.x},${legendConfig.y})`);

                // Add legend title
                legend.append("text")
                    .attr("class", "legend-title")
                    .attr("x", 0)
                    .attr("y", -10)  // Position it above the legend items
                    .text("Keywords");

                const activeKeywords = new Set(keywords);
                const legendItems = keywords.map(keyword => ({
                    keyword: keyword,
                    active: true
                }));

                const legendItem = legend.selectAll(".legend-item")
                    .data(legendItems)
                    .enter().append("g")
                    .attr("class", "legend-item")
                    .attr("transform", (d, i) => {
                        if (legendConfig.layout === 'vertical') {
                            return `translate(0,${i * legendConfig.spacing})`;
                        } else {
                            const row = Math.floor(i / legendConfig.itemsPerRow);
                            const col = i % legendConfig.itemsPerRow;
                            return `translate(${col * legendConfig.spacing},${row * 25})`;
                        }
                    })
                    .on("click", function(event, d) {
                        d.active = !d.active;
                        d3.select(this).classed("inactive", !d.active);
                        
                        if (d.active) {
                            activeKeywords.add(d.keyword);
                        } else {
                            activeKeywords.delete(d.keyword);
                        }
                        
                        updateChart(Array.from(activeKeywords));
                    });

                legendItem.append("rect")
                    .attr("width", 10)
                    .attr("height", 10)
                    .style("fill", d => z(d.keyword));

                legendItem.append("text")
                    .attr("x", legendConfig.textOffset)
                    .attr("y", 9)
                    .style("font-size", isDesktop ? "12px" : "10px")
                    .style("text-anchor", "start")  // Always left-aligned
                    .text(d => d.keyword);

                // Add event listeners for the sliders
                yearStartSlider.addEventListener('input', function() {
                    if (parseInt(yearStartSlider.value) > parseInt(yearEndSlider.value)) {
                        yearStartSlider.value = yearEndSlider.value;
                    }
                    startYearLabel.textContent = yearStartSlider.value;
                    updateChart(Array.from(activeKeywords));
                });

                yearEndSlider.addEventListener('input', function() {
                    if (parseInt(yearEndSlider.value) < parseInt(yearStartSlider.value)) {
                        yearEndSlider.value = yearStartSlider.value;
                    }
                    endYearLabel.textContent = yearEndSlider.value;
                    updateChart(Array.from(activeKeywords));
                });
            });
        }

        function saveSvgAsFile() {
            const svg = document.querySelector('svg');
            
            // Deep clone the SVG
            const clone = svg.cloneNode(true);
            
            // Convert SVG to string
            // Inject CSS styles directly into the SVG
            const styleSheet = document.createElement('style');
            styleSheet.textContent = Array.from(document.styleSheets)
                .filter(sheet => !sheet.href) // Only include internal styles
                .map(sheet => Array.from(sheet.cssRules)
                    .map(rule => rule.cssText)
                    .join('\n'))
                .join('\n');
            clone.insertBefore(styleSheet, clone.firstChild);
            
            const svgData = new XMLSerializer().serializeToString(clone);
            
            // Add XML declaration and doctype
            const svgContent = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n' +
                            '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
                            svgData;
            
            const svgBlob = new Blob([svgContent], {type: 'image/svg+xml;charset=utf-8'});
            
            // Download SVG file
            const downloadLink = document.createElement('a');
            downloadLink.download = 'keywords_over_time.svg';
            downloadLink.href = URL.createObjectURL(svgBlob);
            downloadLink.click();
            
            // Clean up
            URL.revokeObjectURL(downloadLink.href);
        }

        // Initial creation
        createChart();

        // Redraw on window resize
        window.addEventListener('resize', debounce(createChart, 250));

        // Debounce function to prevent too many redraws
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Update the click handler to use the new function name
        document.querySelector('.save-button').addEventListener('click', saveSvgAsFile);

        // Update button text
        document.querySelector('.save-button').textContent = 'Save as SVG';
    </script>
</body>
</html>